# Object.prototype.toString.call(null) // “[object null]” 判断最完整
# typeof
除了null的基本类型、object、function
# instanceof X
检测实例的原型是否该构造函数X的prototype
function newInstanceOf(left, right) {
    let rightProto = right.prototype;
    let leftP = left.__proto__;
    while(true) {
        if (leftP === null) return false;
        if (leftP === rightProto) return true;
        leftP = leftP.__proto__;
    }
}
# Array.isArray()   isNaN()

# 原型
内置属性__proto__ ，指向创建它的构造函数的原型对象
对象之间通过__proto__连接起来的对象链， 当前对象找不到该属性，往上找，直到null。
任何对象都具有隐式原型属性（__proto__），只有函数对象有显式原型属性（prototype）

# 继承
父类.call(this)
子类prototype = Object.create(父类prototype);
子类constructor指向自己

Extends  super 类似call 执行父类构造函数

# new 关键字
新生一个对象——其__proto指向构造函数的原型——构造函数作用域赋给新对象，绑定this——为新对象添加属性，执行构造函数——返回对象
Var obj = {};
Obj.__proto__ = Person.prototype;
Person.call(obj);
Return obj;

# 事件循环机制
Js是单线程语言，通过事件循环机制模拟异步操作。

# 事件机制
冒泡和捕获
委托

# Webpack ??
	基本修改

# Vue
# Vuex
# Package
Dependencies 在生产环境中需要用到的依赖
devDependencies 在开发、测试环境中用到的依赖 ,babel\eslint\vue-loader\webpack
# Router
# Axios
# Vue keeplive缓存
有些组件没有必要重复初始化，组件缓存
keepalive是一个抽象组件，缓存vnode，缓存的组件不会重走生命周期。
被包含在 keep-alive 中创建的组件，会多出两个生命周期的钩	子: activated 与 deactivated：
如从列表页跳到详情页
include=”a,b”是需要缓存name为a或b的组件；
	exclude是除了某些组件都缓存，优先级高些；
max
 	<keep-alive> 
<router-view> 
<!-- 所有路径匹配到的视图组件都会被缓存！ --> 
</router-view> 
</keep-alive>

# 组件化
组件自调用
组件component install

# Git
# Promise
# Js缓存
强缓存： response头，cache-control（缓存开关）字段验证是否可用，请求头也可以模
拟，勾选disable chche
协商缓存：读取不到强缓存，发送请求，请求头带上If-Modified-Since和If-None-Match，	服务器判断是否需要更新。
# 冒泡
# 快排
# 防抖
	防止函数多次调用，使用最后一次调用

# 节流
	防止函数多次调用，定时触发函数

# 垃圾回收
	js的内存管理是自动执行，不可见。

	js引擎有一个后台进程，叫垃圾回收器，监视所有对象，并删除那些不可访问的对象。

		如一个变量，指向一个对象。这个变量重新赋值，对象没有了对它的引用，垃圾回收器就会回收并释放内存。
	
	垃圾：
		一般来说，没有被引用的对象
	如何检垃圾
		通过一种算法 标记-清除算法
# 性能优化
http缓存优化

页面加载及渲染过程优化
	渲染流程
	懒加载无限列表
Dom优化
	删除不必要的代码和注释包括空格，尽量最小化文件
	利用GZIP压缩文件
	结合HTTP缓存文件
CSS优化
	减少关键CSS元素数量

总的：
	最小化关键字节数，减少下载时间
	最小化关键资源数，消除内联、推迟下载或异步解析等。
	优化加载资源顺序，让关键资源尽早下载

	浏览器渲染页面，谷歌翻译：css放head，js放body，js异步加载async、defer
	减少http请求：
		css js 合并打包
		小图标用iconfont代替
		复杂图片使用base64格式的图片
	减少静态资源的体积
		压缩静态资源，gulp、webpack，个别图片有一个网站可以在线压缩
		高效率css，防止css预处理器滥用，嵌套冗余
		服务端开启gzip压缩


# cookie sessionStorage   localStorage 共通和区别
webstorage: 本地存储，存储在客户端，存储字符串，一般5M，节省网络流量，不参与服务器通信
	window.sessionStorage 当前会话有效，关闭页面即清除，不共享
	window.localStorage  永久保存，除非清除，在所有同源窗口共享
	可直接使用api
		setItem (key, value) —— 保存数据，以键值对的方式储存信息。
		getItem (key) —— 获取数据，将键值传入，即可获取到对应的value值。
		removeItem (key) —— 删除单个数据，根据键值移除对应的信息。
		clear () —— 删除所有的数据
		key (index) —— 获取某个索引的key
cookie：4kb，与服务端通信，每次会携带在HTTP头中，Http请求发送set-cookie HTTP头作为响应一部分，根据name=value存储，一般不超过20个。过多会带来性能问题。
	在所有同源窗口共享
	默认是浏览器关闭失效，可以设置失效时间。
	易用性不好，需要自己封装

注意xss注入，不要存储敏感信息

# 盒子模型
	width	padding	border	margin

	IE怪异模式
	content包括width、padding、border

	box-sizing: content-box / border-box(IE)
# IE内核
	trident

# 对象和字符串的互相转换
字符串转对象 3方式：
	JSON.parse(str)
	eval("("+str+")")
	(new Function("return " + str))()

# for 一类的区别？  效率最快是？

# 单点登录

# get post
get： 读取，
	可以对请求对数据做缓存、可书签、可保留历史记录。
	用url传输数据
	不安全，明文
	编码只支持ASCII
	因url长度限制，如chrome的url限制是2M， 都比IE大
	回退没事
post：提交
	不能缓存，不能书签和历史记录
	用body传输数据
	只是较安全，不过通常用https，SSL协议
	支持任意binary
	不限制
	回退会再次请求

# jsonp只能get？
jsonp的实现是通过script可跨域的特性实现
根据script标签src属性指定请求路径去请求，显然是get方式
