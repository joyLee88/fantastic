# 一 、TypeScript类型检测
    javascript是动态类型，在运行时进行检测；
    typescript是静态类型，编译阶段能确定变量类型，进行类型检查；只在编译时对类型进行静态检查。

    typescript和JavaScript一样，是弱类型，能隐式类型转换。 1+ '1' // '11'

    : 指定变量的类型。


# 二、 test开发：
    vue-cli  4.x
    在已存在js项目安装typescript
        vue add @vue/typescript
            use class-style
            use Babel alongside typescript
    组件编写
        ts编写有3种常用方式 Vue.extend()、@component、tsx
    
    @component

# 三、 基础 （快速刷一遍）
## 1. 原始数据类型
    boolean、 number、string、undefined、null、symbol、bigInt

1.1 :boolean
let createdByNewBoolean: Boolean = new Boolean(1); //boolean 是 JavaScript 中的基本类型
let createdByBoolean: boolean = Boolean(1); // Boolean 是 JavaScript 中的构造函数

1.2 :number
1.3 :string
1.4 空值
js没有空值void的概念，在ts中，用void表示没有任何返回值的函数。
function alertName(): void {
    alert('My name is Tom');
}

1.5 null和undefined
与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量

// 这样不会报错
let num: number = undefined;
// 这样也不会报错
let u: undefined;
let num: number = u;

## 2. 任意值
任意值（Any）用来表示允许赋值为任意类型。

如果是一个普通类型，在赋值过程中改变类型是不被允许的：
    let myFavoriteNumber: string = 'seven';
    myFavoriteNumber = 7;
    // index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.

任意值可以再赋值任意类型，并可以访问其任意属性或任何方法；对它的任意操作，返回的内容类型都是任意值。

变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型！
    let something; // 注意，是声明

## 3. 类型推论
mean: 如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。

如，第一行虽然未指定类型，但是赋值是字符串，推论为字符串类型。
let myFavoriteNumber = 'seven';
myFavoriteNumber = 7;

// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.

## 4. 联合类型
表示取值可以为多种类型中的一种；使用 | 分隔每个类型
let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven';
myFavoriteNumber = 7;

联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：
let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven';
console.log(myFavoriteNumber.length); // 5
myFavoriteNumber = 7;
console.log(myFavoriteNumber.length); // 编译时报错

## 5.对象
在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。
5.1 接口一般首字母大写；
5.2 赋值的时候，变量的形状必须和接口的形状保持一致，定义的变量比接口少了一些属性是不允许的，多一些属性也是不允许的；

定义了一个接口 Person，接着定义了一个变量 tom，它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致
interface Person {
    name: string;
    age: number;
}
let tom: Person = {
    name: 'Tom',
    age: 25
};

5.3 不完全匹配一个形状，可以用可选属性
interface Person {
    name: string;
    age?: number; // age可以不存在
}

5.4 任意属性
使用 [propName: string] 定义了任意属性取 string 类型的值；一个接口只能定义一个任意属性；多个类型可以用联合

一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：
interface Person {
    name: string;
    age?: number;
    [propName: string]: string;
}
可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错

5.5 只读属性
有些字段只能在创建时赋值，使用readonly
interface Person {
    readonly id: number;
}

## 6.数组
方式1：类型[] 表示类型数组；也可any
let fibonacci: number[] = [1, 1, 2, 3, 5];

方式2：Array<类型> 数组泛型
let fibonacci: Array<number> = [1, 1, 2, 3, 5];

方式3：interface NumberArray { // 用接口表示数组
    [index: number]: number;
}
let fibonacci: NumberArray = [1, 1, 2, 3, 5];

arguments类数组

## 7.函数
函数声明
function sum(x: number, y: number): number {
    return x + y;
}
    也可有可选参数，但可选参数后面不允许再出现必需参数了
    添加了默认值的参数识别为可选参数，此时就不受「可选参数必须接在必需参数后面」的限制
    使用...rest获取函数中的剩余参数
    重载
        重载允许一个函数接受不同数量或类型的参数时，作出不同的处理
        function reverse(x: number): number;
        function reverse(x: string): string;
        function reverse(x: number | string): number | string | void {
            if (typeof x === 'number') {
                return Number(x.toString().split('').reverse().join(''));
            } else if (typeof x === 'string') {
                return x.split('').reverse().join('');
            }
        }

函数表达式
let mySum = function (x: number, y: number): number {
    return x + y;
};

用接口定义函数的形状
interface SearchFunc {
    (source: string, subString: string): boolean;
}
let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
    return source.search(subString) !== -1;
}

## 8.类型断言
手动指定一个值的类型
    值 as 类型 或 <类型>值

将一个联合类型断言为其中一个类型
将一个父类断言为更加具体的子类
将任何一个类型断言为any
将any断言为一个具体的类型
    任何类型可以断言为any
    any可以被断言为任何类型

但是！并不是任何一个类型都可以断言为任何另一个类型！

双重断言
    as any as Foo

## 9.声明文件
要使用第三方库，需要引用声明文件。

declare var 定义

把声明语句放到一个单独文件，这就是声明文件，如jQuery.d.ts
    声明文件必需以 .d.ts 为后缀。
    declare var jQuery: (selector: string) => any;
保证解析
    检查下 tsconfig.json 中的 files、include 和 exclude 配置，确保其包含了 jQuery.d.ts 文件

可以直接使用统一管理的第三方库声明文件
    npm install @types/jquery --save-dev
    可搜索其他
        https://www.typescriptlang.org/dt/search?search=

## 10.内置对象
ECMAScript 标准提供的内置对象有：
    Boolean、Error、Date、RegExp 等
DOM 和 BOM 提供的内置对象有：
    Document、HTMLElement、Event、NodeList 等

    let body: HTMLElement = document.body;
    let allDiv: NodeList = document.querySelectorAll('div');
    document.addEventListener('click', function(e: MouseEvent) {
    // Do something
    });
Node.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：
    npm install @types/node --save-dev


# 四、 进阶
1. 类型别名
为了给一个类型起个新名字，常用于联合类型。
    用type创建

2. 字符串字面量类型
字符串字面量类型用来约束取值只能是某几个字符串中的一个。
type EventNames = 'click' | 'scroll' | 'mousemove';
    使用 type 定了一个字符串字面量类型 EventNames，它只能取三种字符串中的一种
* 类型别名与字符串字面量类型都是使用 type 进行定义。

3. 元组
数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。
定义一对值分别为 string 和 number 的元组：
    let tom: [string, number] = ['Tom', 25];


新建文件夹-》npm init -y
安装ts
    npm add typescript -D
npm中的ts-node-dev
    实时修改ts，即修即得
    修改package
        "scripts": {
            "dev": "ts-node-dev --respawn --transpile-only ./demos/demos1.ts"
        }
添加tsconfig.json
    {
        "compileOptions": {}
    }
